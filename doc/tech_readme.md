# 贪吃蛇游戏技术文档

## 1. 系统架构

贪吃蛇游戏采用客户端-服务器架构，通过WebSocket进行实时通信：

- 服务端：使用Go语言开发，负责游戏核心逻辑
  - 游戏状态管理
  - 碰撞检测
  - AI蛇的行为控制
  - 实时状态同步

- 客户端：使用JavaScript开发，负责用户交互和画面渲染
  - 游戏画面渲染
  - 用户输入处理
  - 状态更新展示

## 2. 通信协议

### 2.1 WebSocket连接

- 连接地址：`ws://<server-host>:8080/ws`
- 心跳间隔：无需心跳包，依赖TCP保活机制
- 重连机制：断开连接后最多重试5次，采用指数退避算法

### 2.2 消息格式

所有WebSocket消息采用JSON格式，基本结构如下：

```json
{
    "type": "<message-type>",
    "payload": <message-data>
}
```

### 2.3 服务端消息类型

#### 2.3.1 游戏状态更新（state）

```json
{
    "type": "state",
    "payload": {
        "snakes": {
            "<snake-id>": {
                "id": "string",
                "name": "string",
                "color": "string",
                "isAI": boolean,
                "x": number,
                "y": number,
                "direction": {
                    "x": number,
                    "y": number
                },
                "body": [
                    {
                        "x": number,
                        "y": number
                    }
                ],
                "dead": boolean
            }
        },
        "apples": [
            {
                "x": number,
                "y": number
            }
        ]
    }
}
```

### 2.4 客户端消息类型

#### 2.4.1 方向更新（direction）

```json
{
    "type": "direction",
    "payload": {
        "x": number, // -1, 0, 1
        "y": number  // -1, 0, 1
    }
}
```

## 3. 通信流程

### 3.1 游戏启动流程

1. 客户端连接WebSocket服务器
2. 服务端接受连接，创建新的蛇实例
3. 服务端将新蛇添加到游戏状态
4. 服务端广播更新后的游戏状态
5. 客户端收到状态更新，渲染初始游戏画面

### 3.2 游戏循环

1. 服务端每100ms更新一次游戏状态
   - 更新蛇的位置
   - 检测碰撞
   - 处理吃到苹果的情况
   - 检查AI蛇的生成

2. 客户端
   - 监听键盘输入
   - 发送方向更新消息
   - 接收游戏状态更新
   - 更新画面渲染

### 3.3 玩家断开连接

1. WebSocket连接断开
2. 服务端检测到断开，移除对应的蛇
3. 服务端广播更新后的游戏状态
4. 其他客户端收到状态更新，更新画面

## 4. 错误处理

### 4.1 连接错误

- 客户端采用指数退避算法进行重连
- 最多重试5次
- 重试间隔：1s, 2s, 4s, 8s, 16s

### 4.2 消息解析错误

- 服务端忽略无法解析的消息
- 客户端忽略无法解析的消息
- 记录错误日志但不中断游戏进程

## 5. 性能考虑

### 5.1 状态同步优化

- 服务端每100ms同步一次状态，平衡实时性和网络负载
- 使用WebSocket而不是HTTP轮询，减少网络开销
- 状态更新采用全量同步，简化实现，适合小规模游戏

### 5.2 并发处理

- 服务端使用互斥锁保护游戏状态
- 每个WebSocket连接使用独立的goroutine处理
- 游戏循环使用独立的goroutine运行

## 6. 安全性

### 6.1 输入验证

- 服务端验证方向输入值范围（-1到1）
- 忽略无效的方向输入
- 限制消息大小，防止恶意大数据包

### 6.2 连接管理

- 允许跨域WebSocket连接
- 不要求身份认证（简化实现）
- 服务端限制最大连接数（由系统资源限制）

## 7. 扩展性考虑

未来可以考虑添加的功能：

- 玩家认证系统
- 排行榜系统
- 游戏房间
- 自定义游戏配置
- 观战模式

这些功能可以通过扩展现有的消息类型和添加新的消息类型来实现。